									上午
工具：
	make/makefile  项目自动化管理
		在makefile中定义大量项目编译规则，在命令行执行make命令，
	
	makefile编写规则：
		目标对象：依赖对象
			执行命令
	make执行规则：
		1、寻找第一目标对象：有无目标对象；有则判断目标对象是否存在
			若目标对象不存在：执行命令
			存在：查看是否有依赖对象；若没有，则认为目标对象最新，不需要重新生成；若有则判断依赖对象是否存在
				依赖对象存在：判断双方时间关系，判断目标对象是否需要重新生成
				依赖对象不存在：在makefile中继续找以来对学习生成规则，生成依赖对象，进而生成目标对象
		
		预定义变量：$@$^$<
		伪对象：目标对象每次都需要重新执行（不管是否存在，是否最新）
		声明对象：PHONY
		
	git：项目版本控制工具
		项目克隆：git clone url
		项目提交：git add     git commmit -m "备注信息“
		同步服务器：git push masster 

进度条程序：
	\r和\n
	\n在操作的文件为终端显示文件时，不仅有换行作用，还有刷新缓冲区作用（提高效率）
	
系统编程：
	冯诺依曼体系结构：输入、输出设备、存储器、运算器、控制器
	所有硬件围绕存储器工作，硬件结构决定软件行为（数据流向）；
	
	
	操作系统：是计算机上的一种软件，为了让计算机更好用，更好管理计算机上的软硬件资源
	管理：先描述、后组织
	库与系统调用的关系：
	进程： 运行中的程序，Linux是一个多任务操作系统的代表，表示有大量的程序需要被CPU调度运行，此时CPU使用了分时技术，分别轮询处理每一个程序，在进程 程序切换调度时，需要记录运行信息，因此
	先描述、后组织（系统使用pcb进行描述，使用双向链表将pcb串起来进行管理）
	
	创建进程：fork()      复制父进程pcb（大部分信息）、创建一个子进程
		复制：代码共享，数据独有
		返回值：创建子进程可分摊父进程压力/执行其他任务
			父-->子pid
			子-->0
	
	查看进程：ps -ef  aux
	
	
	Linux进程状态：运行状态、睡眠状态、可中断睡眠中断、停止状态、僵尸状态
		僵尸进程：进程退出了，但是资源未完全释放
		产生原因：子进程先于父进程退出，但是资源没有完全释放，
		解决方法：干掉父进程
		避免方法：进程等待
		孤儿进程：父进程先于子进程退出
		

	进程优先级：通过评级决定CPU资源的有限分配权
		意义：为了让计算机运行的更加合理（进程的性质不同：批处理进程<交互式进程）
		查看优先级：ps -l   PRI
		修改优先级：通过修改NI(nice)值调整PRI(优先级）    PRI=PRI+NI           PRI值越小，优先级越高
		优先级调整：主要用于CPU密集型程序（对CPU资源要求较高），磁盘密集型程序对CPU资源要求不高，因此没必要调整优先级
		
		竞争性：
		独立性：保证每一个进程互不干扰
		并行性：CPU资源足够多，多进程同时处理
		并发性： 
		
	环境变量：保存有设置操作系统运行环境参数的变量
	变量类型：内存解释
	查看环境变量：  env  echo $PATH   
	设置环境变量：export
	删除环境变量：unset
	常见环境变量：HOME SHELL PATH 
	使用代码获取环境变量/特性：int main(int,char**,char* env[])
								extern char**environ
								getenv
	extern关键字用法：改变变量连接属性/作用域，使其可在其他文件使用
	static关键字：定义变量静态作用域...
	
	程序地址空间：
		地址：内存区域的编号
		进程的虚拟地址空间：mm_struct  内存描述符
		操作系统通过mm_struct结构体给进程描述了一个虚拟的地址空间
		使用虚拟地址空间可以提高内存使用率
		分段式内存管理：段号+段内偏移地址
		分页式内存管理：页号+页内偏移地址    通过页号找到页表信息   特点：碎片化、细致化
		虚拟地址采用段页式内存管理方法         段号+段内页号+页内偏移地址
		
									下午
									
	进程创建中的写时拷贝技术：父进程创建了子进程，但是并没有直接给子进程开辟内容，拷贝数据，而是跟父进程映射到同一个位置，但是如果内存中数据发生改变，对于改变的这块内存，需要重新给子进程开辟内存，并且更新页表信息。提高子进程创建性能。
	
	
	
	进程的O(1)调度算法：队列数组  
	
	
进程控制：
	进程创建：fork()————复制，返回值，写实复制
			vfork()创建子进程时，子进程与父进程共用同一块虚拟地址空间，为防止调用混乱，因此阻塞（挂起）父进程直到子进程退出或者进行程序替换
			vfork创建的子进程在main函数中不能用return 退出，释放资源后父进程会崩溃
			
			fork vfork   clone  三者关系：fork和vfork在创建子进程时都是调用clone函数实现进程创建的
			
	进程终止：进程退出
		正常退出，结果符合预期
		正常退出，结果不符合预期
		异常退出
		
		终止方式：main函数中return  exit()库函数，退出时刷新缓冲区    _exit() 系统调用接口，退出时，不刷新缓冲区，直接释放资源
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	