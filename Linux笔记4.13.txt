程序地址空间：mm_struct结构体
	使用虚拟地址空间+页表的原因：保持进程的独立性/充分利用内存/内存访问控制
	段页式、页式、段式内存管理
	
进程调度算法：

进程控制：
	进程创建：
	fork()函数：父子进程数据独有，代码共享    
	vfork()：父子进程共用虚拟地址空间，子进程先运行(不常用）
	
	进程终止:
	
	
	进程等待：等待子进程退出——避免僵尸子进程+获取子进程返回值
	wait(int *) / waitpid(int pid,int *,int opt)
	
	阻塞：发起调用完成功能，若当前不具备完成条件，则一直等待直到完成后返回
	非阻塞：发起调用完成功能，若当前不具备完成条件，则立即报错返回
	
	获取子进程返回值：statu格式
		————低16位中的高8位存储子进程返回值
		————低16位中低8位中的高1位存储core dump标志；低7位存储异常信号值
		statu & 0x7f ==0（表示程序正常退出）    0xff & (statu>>8)获取返回值
		
程序替换：替换一个进程正在运行的程序，让进程的虚拟地址空间映射到内存中另一个程序的代码和数据位置，让子进程执行其他任务（目的：程序崩溃后不影响父进程）

	execl execlp execle     execv   execvp   execve
	
	l:运行参数以函数参数平铺形式赋予        execl(ls,ls,-l,-a,NULL)
	v:运行参数以一个字符串指针数组赋予      arg[]={'ls','-l','-a',NULL};   execv(ls,*arg);
	P:无p,程序运行名称必须带路径;有p,去path环境变量指定路径寻找程序
	e:无e,程序使用默认环境变量；有e,自定义环境变量
	
实现minishell:
	
	1、获取标准输入中的字符创
	2、对字符串进行解析[ls,-l,-a]
	3、创建子进程
		子进程中进行进程替换
	4、父进程进行进程等待（避免僵尸进程）
	
基础IO:输入输出
	标准库IO接口：FILE*   文件流指针
	fopen 	fclose	 fread	 fwrite	 fseek(跳转文件读写为止) 	fgets   printf/fprintf/sprintf
	
	注意fwrite、fread返回值；对文件中数据处理时，使用字符串处理函数有可能遇到空数据，导致文件处理不完整。
	
	
	系统调用IO接口：int    文件描述符            
	open 	write 	read	lseek	close

	memset(buf,0x00,1024)    初始化buf的内存地址
	
	文件描述符和文件流指针关系：文件流指针是标准库操作句柄，文件描述符是系统调用句柄
	文件流指针包含了文件描述符这个成员变量。
	库函数与系统调用接口的关系：库函数封装系统调用接口   
	
	
	what is 文件描述符：文件描述符是内核中struct file* fd_array[数组下标]
	
	文件描述符分配规则：最小未使用
	
	重定向：改变文件描述符所对应的描述信息（改变了数据流行，数据从原本要写入的文件流向了新的文件）。
	重定向不能在父进程中完成的，父进程是需要打印数据的。
	
	minishell中重定向的实现：
	在原有字符串解析完毕的情况下，通过[ls-l >a.txt]解析之后获取得到
	argv[]={"ls","-l",">","a.txt",NULL}  
	在子进程中判断argv中是否包含>或>>来决定是否需要重定向，
	以及重定向方式（> 清空,>>追加）；
	fd=open(O_TRUNC/O_APPEND);   
	dup2(fd,1)将标准输出冲顶下到指定文件中
	
	
	\n刷新缓冲区仅仅针对的标准输出文件，对其他磁盘文件并不具备刷新缓冲区效果
	系统调用因为没有缓冲区，所以不会执行刷新缓冲区
	
	程序运行从用户态切换到内核态运行（切换方法：发起系统调用/程序异常/程序中断）
	区别：完成的功能是由用户自实现接口还是系统调用接口（当前功能自实现还是系统实现）
	
