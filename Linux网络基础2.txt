应用层：
	作用：负责应用程序之间的数据沟通
	抓包工具:fiddler   抓取htpp数据包
	
	HTTP协议(超文本传输协议)：基于tcp协议实现的应用层协议，在传输层默认使用80端口，使用字符串明文传输
	格式：
	首行：以空格进行间隔，分三部分
		请求首行：请求方法、url、协议版本
			请求方法：GET/POST/HEAD/PUT/DELETE  区别：get无正文，post有正文  get提交数据在url(长度有限)中，post提交数据在正文中
			协议版本：0.9/1.0/1.1/2
			
		响应首行：协议版本、响应状态码(200、302、404、502)
		
	头部:以冒号空格形式组成的键值对，以\r\n结尾
	content Length/content type/referer /cookie /set cookie/location/transfer encoding
	
	空行:\r\n间隔头部与正文
	
	正文:
	
	http服务器(基于tcp)处理数据流程：
		1、获取http头部(首行+头部)
		2、获取数据
		3、根据头部中的请求处理数据
		
传输层：
	作用：负责端与端之间的数据传输
	端口：一个端口只能被一个进程占用，一个进程可以使用多个端口
	五元组：源ip、源端口、目的ip、目的端口、协议   用于表示一条通信从哪儿来到哪儿去
	常用协议：TCP/UDP协议
	
	UDP协议:
		udp字段：16位源端口/16位目的端口——负责端与端之间的数据传输
				 16位校验和：：验证数据段的一致性
				 16位udp数据报总长度:最大(2^16-1)，若发哦少年宫长度大于等于64k则需要用户在应用层将数据手动进行分段，
				 因为Udp不会再传输层自动对数据进行分段。
				 
		特点：无连接、不可靠、面向数据报
		无连接不可靠：不需要建立连接，只用直到地址信息就可以发送数据，不关心是否发到
		面向数据报：数据只能整条交付给用户；传输不够灵活，但是不会产生粘包问题(因为长度固定)
		
		udp不保证数据报的有序到达，需要用户在应用层进行包序管理
		
	TCP协议：
	特点：面向连接、可靠传输、面向字节流
	tcp连接管理：
	
	【相关问题】：
	三次握手建立连接流程
	1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

	2.Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

	3.Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
	
	四次挥手断开连接流程
	由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

	1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。

	2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。

	3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认

	4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。
	
	为什么握手三次，挥手四次
	三次握手原因：

	三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。

	服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。
	
		为什么TCP协议终止链接要四次？

	1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。

	2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。

	3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。

	4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。
	三次握手失败，服务端是如何处理的
	
	TIME_WAIT状态作用
		1、加入没有TIME_WAIT，客户端直接关闭，但是有重启了相同地址的客户端，
		有可能因为四次挥手最后一次的ACK丢失，导致服务端重传FIN包，堆后序链接造成影响，
		新客户端发送SYN到服务端，服务端认为状态有误，回复重置链接报文——RST报文
		因此主动关闭方发送最后一个ACK后不能直接关闭，需要等待一段时间后(2个MSN时间)
		MSN时间：报文最大生存周期
		等待两个MSN时间是为了能够处理对端重传的FIN包进行ACK回复
		并且等待两个MSL时间是为了让所有网络中延迟的报文都小时在网络中，不会对后序连接造成影响
	
	服务端出现大量TIME_WAIT的原因及解决方法
		程序主动退出会导致大量TIME_WAIT出现，设置套接字选项，是地址重复使用可以解决
	
	可靠传输：
		连接管理、确认应答机制、超时重传机制、序号/确认序号/校验和
		TCP为了实现可靠传输导致部分性能的牺牲，但是有些牺牲是没必要的比如：确认应答的丢失导致数据重传
									   ↓↓↓↓			
									    ↓↓
		滑动窗口机制：一次性可以发送大量数据，然后等待回复
		
		滑动窗口的流量控制：
		通信双方通过协议字段中的窗口大小来协商接下来应该发送的最大长度
		窗口大小不大于当前接收缓冲区的空闲空间大小，避免因为发送数据过多导致缓冲区放满，而丢失数据重传
		
		确认回复中的ack确认序号能够表示，这个序号之前的数据都已经接受到了
		若前边的数据没有接收到，反而接收到了后边的数据，则不会对后边的数据进行ack确认
		
		快速重传机制：当接收端接收数据时，若第一条数据没到，但是接收到了后序数据，则认为第一条数据可能丢失，
					  接收端立即向发送端连续发送三次重传请求，发送端接收到三次请求，则对这条数据进行重传
					  
		拥塞窗口机制：通信初始双方协商窗口大小，窗口可能很大，一次发送大量数据，可能会因为网络情况导致大量丢包，导致重传，降低效率，因此就需要一个拥塞窗口来控制或限制发送端的发送数据量的大小，这个数字会随着每次的ack响应而快速增长，一旦出先重传，则立即重新初始化
					  
		延迟应答机制：尽可能的保证窗口大小，因为接收方有可能很快将数据从缓冲区拿走，保证吞吐量，防止传输速度降低
		
		捎带应答机制：尽可能避免大量纯报头(垃圾数据)的确认回复
		
		
					  
		
		
		
		
		
		
		
		
		
		