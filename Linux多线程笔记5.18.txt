多线程：  理解——>进程与线程的优缺点——>线程的独有与共享
	生产者与消费者模型：一个场所，两种角色(生产者、消费者），三种关系(生产者——生产者互斥、消费者——消费者互斥、生产者——消费者同步+互斥)
		功能：解耦（耦合度：数据之间的依赖度)、支持忙闲不均、支持并发
		实现：1、实现线程安全的队列，对外提供线程安全的数据入队、出队操作
			  2、创建线程，分别为生产者与消费者数据入队或数据出队。
			  private:
					std::queue<int> q;   // stl容器中的队列
					int cap;             // 队列结点最大数量
					// 线程安全实现成员
					pthread_mutex_t lock;
					pthread_cond_t full;
					pthread_cond_t empt	y;
					
					
	POSIX信号量：具有等待与唤醒功能的计数器
		原理：通过自身的计数器实现条件判断，当条件满足时则直接返回，并且计数-1；条件不满足时则阻塞。
			  当生产资源后，通过信号量的唤醒功能唤醒等待并且计数+1
		信号量和条件变量实现同步的区别：
			1、信号量的条件判断由自身完成，而条件变量的条件判断由用户完成。
			2、信号量并不搭配互斥锁使用，条件变量必须要搭配互斥锁一起使用(条件变量需要对临界资源进行操作)保护条件的改变
		
		
		信号量的操作步骤：
			sem_t    	 定义
			sem_init     初始化
			sem_wait      计数-1，判断是否阻塞
			sem_post     计数+1，唤醒阻塞
			sem_destroy   销毁
			 
		使用顺序表实现环形队列：
				RingQueue{ 
					std::vector<int> _queue;
					int _capacity;
					int _read_step;    // 环形队列读指针
					int _write_step;  // 环形队列写指针
					
					// 使用信号量实现同步与互斥
					sem_t sem_lock;       // 实现互斥
					sem_t data_sem;      // 数据资源计数
					sem_t space_sem;    // 空闲空间计数
					};
					
		线程池：一堆线程 + 任务队列（线程安全）
			作用：1、避免大量线程频繁的创建和销毁时间成本
				  2、避免瞬间大量线程创建耗尽资源导致程序崩溃
				  3、提高任务的并发处理性
			
			实现：创建固定数量的线程 + 创建一个线程安全的队列
				创建一个任务类
				创建线程池类：
					1、创建线程
					2、创建线程安全队列
				
			
			
			线程池的种类及使用场景：
			
			
	设计模式：大佬们针对典型场景设计出来的解决方案
	
	常用设计模式种类及使用场景：
	
	单例模式：设计模式的一种，一个对象只能被实例化一次(一个类只能实例化出一个对象)，资源只能被加载一次
	
	单利模式的实现：
		饿汉模式：资源在程序初始化时一次性全部加载（初始化时实例对象）
			
		懒汉模式：资源在使用时加载，对象在使用时再实例化
		
		
	锁的种类特性及使用场景：
		
			