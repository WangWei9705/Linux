常用工具：
	make/makefile:项目自动化构建工具
	makefile是普通文本文件，记录了项目构建的流程规则
	make:是一个解释程序，到当前执行make命令的目录下寻找makefile文件，并且对makefile记录的项目构建规则进行解释执行
	Makefile编写规则：
		目标对象：依赖对象
		【Tab】 命令
		
		
		
		
		
		
		
		
		
	预定义变量：
		$@:目标对象
		$^:所有依赖对象
		$<:
		
	.PHONY用于声明伪对象，不管目标对象是否最新，每次都重新生成
		
    关键字：
	
	
	
	
	git:项目版本控制工具
		git:分布式
			三板斧：
					下载：git clone url
						
					
					提交:git  add      git commit -m "备注"
					
					上传:git push origin master
					
		svn:集中式
		
	进度条程序
	Printf("\n");
	打印数据就是把数据写入到标准输出文件中
	fflush  刷新缓冲区
	\r 回车符   ，让光标回到下一行的起始位置
	
	缓冲区对文件读写的影响：数据并没有直接写入文件，而是先写入到缓冲区，等到缓冲区满了或缓冲区刷新之后才会将数据真正写入到文件
	
系统编程阶段：

	冯诺依曼体系结构：计算机硬件五大单元
		输入设备：键盘
		输出设备：显示器
		存储器：内存
		运算器：CPU
		控制器: CPU--主频
		
		所有硬件设备都是围绕存储器工作的
		硬件结构决定软件行为
		
	操作系统：一个安装在计算机上的软件，
		目的：为了让计算机更加好用，
		功能：统筹管理计算机上的软硬件资源
		管理：先描述（用结构体描述），再组织（大部分通过链表来组织）    
			  操作系统通过驱动获取硬件描述信息将硬件组织起来进行管理
	
	库函数与系统调用接口的关系：库函数封装了系统调用接口，是上下级调用关系
	
	进程：
		概念：简单来说就是进行中的程序，
		操作系统通过PCB来控制一个进程的运行，这个PCB也叫进程描述符，描述了一个运行中的程序，在操作系统角度，进程就是PCB
		
		一个PCB相当于一个内存指针，存储着指定程序的位置信息
		
		CPU的分时机制：切换调度进程，每个进程只运行很短的时间，这个时间被称为时间片
		
		进程标识符：PID
		进程状态：
		进程优先级：交互式进程 > 批处理进程    让操作系统运行的更加合理
		IO状态信息：
		记账信息：
		
	进程查看：
		ps -ef aux
		/proc      保存系统正在运行进程信息
		getpid()    获取调用进程pid
		
	进程创建：
		创建一个pcb
		fork()  通过【复制】调用进程（父）创建一个新的进程（子）
		
		
		父子进程代码共享，【“数据独有”】
		分辨父子进程：通过返回值判断
				父进程：返回子进程PID
				子进程：返回0
				失败：返回-1
				
		创建子进程的意义：1、分摊父进程压力，CPU资源进程足够的情况下， 父子进程同时处理，效率更高、
						  2、希望子进程完成其他任务
	进程状态：    就绪、运行、阻塞
	Linux进程状态：
	常见：	运行状态（R)：包含就绪和运行
			可中断睡眠态（S)：  
			不可中断睡眠态(D)：
			停止态（T)：nothing to do
			僵尸态（Z)：
	不常见：死亡态（X):进程退出的瞬间
			追踪态(t):

	
	僵尸进程：处于僵死状态的进程（进程退出后资源没有完全释放，即未完全退出）
		如何产生：子进程先于父进程退出，将自己的退出原因保存在pcb中，操作系统监测到子进程退出，因为父进程可能关注子进程退户原因，所以操作系统不能随意释放所有资源，但是父进程可能没有及时关注到子进程退出，导致子进程退出了但资源未完全释放，使子进程处于僵死状态，称为僵尸进程。
			危害：导致资源泄露，一个用户可以创建的进程是有限的（僵尸进程达到一定数量时，可能导致新进程创建失败）
		处理办法：强杀父进程 （不可取）
		避免办法：进程等待
		
		孤儿进程：父进程先于子进程退出，子进程成为孤儿进程，运行在后台，父进程成为1号进程
		
		守护进程/精灵进程：特殊的孤儿进程（脱离中断、脱离会话的孤儿进程）   服务类程序都是孤儿进程
		
			kill proc_pid     杀死进程
			kill -9 强杀
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	