高级IO：
	五中典型IO：
	IO操作流程：等待IO操作条件具备，然后进行数据拷贝
		阻塞IO：为了完全IO操作发起调用，若当前不具备IO操作条件，则等待，直到条件具备，完成操作后调用返回
		
		非阻塞IO：为了完全IO操作发起调用，当前不具备IO操作，则立即报错返回，
				  此时可以去进行其它操作，循环回来进行判断（缺乏实时性）
		
		信号驱动IO：提前对IO信号进行自定义处理方式，当IO条件具备时，操作系统通过信号通知进程发起IO调用，
					因为此时IO条件已具备，直接发起调用进行数据拷贝
		
		异步IO：IO操作条件的等待与数据拷贝都由操作系统进行等待与操作，
				等到IO操作完成之后，通过信号通知进程，进程直接对数据进行操作
				
	优缺点：IO操作效率越来越高，但是流程控制越来越复杂。	
		
		阻塞与非阻塞：
			阻塞：当前不具备操作条件时，调用挂起等待，直到条件具备，完成操作后调用返回
			非阻塞：当前不具备操作条件，调用立即报错返回
			
			阻塞与非阻塞关注的不是操作是否完成，而是调用是否立即返回
			
		同步通信与异步通信：
			同步：当前不具备操作条件时，调用挂起等待，直到条件具备，完成操作后调用返回
			异步：发起操作的调用，这个操作并不由进程自己完成，而是由操作系统完成
			
			同步与异步关注的是操作是否由进程自己完成
			
		同步通常是阻塞的，但是异步可能是阻塞的也可能是非阻塞的
		
		异步阻塞：发起调用完成功能，功能由操作系统完成，但是进程一直等待操作系统完成，完成之后返回
		
		异步非阻塞：发起调用完成功能，功能由操作系统完成，进程自身直接立即返回进行其它操作
		
		
		异步阻塞与异步非阻塞功能都是由操作系统来完成，关键在于是否进行等待
		
		**Linux下的AIO
		
		IO多路转接/IO多路复用：对大量描述符进行事件（可读/可写/异步事件）监控
			作用：替进程监控大量描述符，告诉进程什么时候有什么事件，进而进程可以轮询针对发生了相应事件的描述符进行相应的操作
			IO多路转接(服务端的高并发)三种模型：
				select
				poll(已被淘汰)
				epoll
