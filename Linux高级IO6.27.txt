IO多路转接/IO多路复用：对大量描述符进行事件（可读/可写/异常事件）监控
		作用：替进程监控大量描述符，告诉进程什么时候有什么事件发生，
				进而进程可以轮询针对发生了相应事件的描述符进行相应的操作
		IO多路转接(服务端的高并发)三种模型：
			select	
				https://www.cnblogs.com/-zyj/p/5719923.html
				原理：①用户自己定义相应事件的描述符集合fd_set ；
						用户将关心的描述符根据自己关心的事件添加到相应集合中
						②select将集合拷贝到内核进行遍历轮询，判断有没有描述符就绪了相应的事件
						③若集合中有描述符就绪，先将集合遍历完毕，然后将没有就绪的描述符从集合中移除；
						此时调用返回，通知进程有多少个描述符就绪了（此时集合中保存的都是就绪的描述符）
						④进程通过轮询遍历所有的描述符是否在集合中，找出就绪的描述符（描述符若在集合中，
						则它就是一个就绪的描述符），进而对这个描述符进行相应的处理
						
				函数原型：int select(int nfds, fd_set *readfds, fd_set *writefds,
							  fd_set *exceptfds, struct timeval *timeout);
							  
						fd_set 是一个文件描述符集，大小由FD_SETSIZE决定，一般是1024
						nfds 被监听的文件描述符的总数，一般为所有描述符的最大值＋1；提高内核中监控效率
						readfds、writefds、exceptfds  可读、可写、异常事件监控集合，关心哪种事件就将其添加到哪个集合中
						timeout  select默认是一个阻塞监控，timeout为超时等待时间，若为空则一直阻塞直到有描述符就绪或者出错
						
						返回值：>0 就绪描述符个数   =0 等待超时，无描述符就绪  <0 监控出错(描述符被关闭)
						
						使用之前需要先清除
					
					
				优点：1、遵顼posix标准可以跨平台使用；2、监控的超市等待时间可以精细到微秒；
					
				缺点：1、select能够监控的描述符有限(1024)；
					2、select实现原理是在内核中对描述符进行轮询判断，性能随着米哦啊舒服的增多而降低
					3、select并不会告诉用户具体哪个描述符就绪，（只给了一个就绪集合），
						因此需要用户自己判断，而得到的就绪描述符的过程是一个遍历的过程，性能会随着描述符增多而降低；
					4、select会修改米哦啊舒服集合，每次监控需要用户重新向集合中添加描述符，性能降低，复杂度增加
					5、每次都需要重新将集合拷贝到内核中
					
					
			poll(已被淘汰)：
					原型：int poll(struct pollfd *fds, nfds_t nfds, int timeout);
					
					fds 描述符事件结构数组
					nfds   要监控的事件的个数
					timeout  超时等待时间（毫秒）
				
					原理：1、用户定义描述符事件数组，向数组中添加关心的描述符事件
						2、将pollfd事件数组拷贝到内核中进行遍历轮询监控，判断是否就绪了关心的事件
						3、将描述符实际就绪的事件信息标记到revents中
						4、当poll返回，用户遍历pollfd数组，判断每一个事件revents是否关心的事件，进而对 其操作
					
					优点：1、描述符数量无限制；    
						  2、poll采用事件结构形式对事件进行监控，简化了select三种集合操作的流程
					缺点：1、只能在Linux下使用，不能跨平台    2、在内核中轮询进行判断就绪，性能随着描述符的增多而降低
					3、不会告诉用户具体哪一个描述符就绪，需要用户轮询遍历判断事件中的revents 
					4、需要每次向内核中拷贝数据 
			epoll（Linux下性能最高的多路复用技术）	
 