IPC
	信号量：计数器（资源计数）+等待队列+等待与唤醒功能
			实现进程间同步与互斥
		
信号：软中断，通知进程发生了某个事件，打断进程当前的阻塞操作，去处理这个事件。
	信号的生命周期：产生（硬件/软件（kill命令/kill函数/raise函数/about()/alarm())——>在进程中注册——>注销——>处理
	
	coredump(核心转储）:当进程异常退出时保存进程运行信息，方便事后调试
	ulimit -a查看     ulimit -c 设置 
	
	注册：pcb中的结构体struct sigpending
		未决信号：暂时未被处理的信号（产生到处理之间的信号）
		sigset_t (一个数组)——>作为二进制比特位位图使用，标记信号是否到来
		可靠与非可靠注册
		
		
		
	注销：消除信号存在的痕迹，避免事件重复处理
		删除结点，修改位图
		
		
	信号处理：
		默认处理方式
		忽略处理方式
		自定义处理方式
	
	竞态条件：多个运行时序的竞争执行
		可重入函数与不可重入函数：函数在多个运行时序中是否可以被同时进入，且不出问题（数据二义/程序逻辑）
			关键点：全局数据是否进行了全局数据的非原子操作
			
	关键字：
	volatile：保持内存的可见性，防止编译器过度优化
		被volatile关键字修饰的变量每次使用需要重新从内存中获取数据
		
	SIGCHLD信号：操作系统通过该信号通知父进程有子进程退出，默认忽略处理
	
	
***** Linux多线程：
		进程：传统操作系统上进程就是pcb，操作系统通过控制pcb控制程序运行。
		
		线程概念：Linux下线程使用pcb模拟实现，Linux下pcb是线程（轻量级进程）
				轻量化：同一个进程中的线程共用同一个虚拟地址空间
				此时进程就是线程组
			进程是资源分配的基本单位——操作系统将资源分配给整个线程组
			线程是CPU调度的基本单位——CPU调度时通过pcb调度程序运行
		
			线程之间的独有与共享：
				独有：栈     寄存器     信号屏蔽字		errno   线程标识符
				共享：虚拟地址空间（数据段、代码段）  文件描述符表  信号处理方式  工作路径  用户id,组id
			
			多线程与多进程任务处理优缺点对比：
			
			对主程序稳定性要求更高时优先选择多线程任务处理方式。
				
				优点：由于同一个进程中的线程共享同一个虚拟地址空间
					  通信方便、线程创建与销毁相对于进程成本更低、在CPU上调度成本更低、执行力度更加细致
					
				缺点：线程间缺乏访问控制、编码难度更高、健壮性较低
				
		线程控制：操作系统并没有提供线程创建接口，因此创建或使用时都是调用库函数(创建的线程是一个用户态线程，但是在内核中对应有一个轻量级进程实现线程程序的调度)
		
		线程创建：pthread_create
		pcb->pid  LWP 轻量级进程id 
		pcb ->tgid PID 进程id
		tid      线程空间首地址
		
		线程终止： 
			在任意进程中不能使用exit退出，因为exit退出的也是整个进程。
			
			在普通线程中使用return退出，但是在main函数中不能使用return退出，因为退出的是整个进程。
			
			pthread_exit    主动退出
			
			pthread_cancel   线程被动退出

			线程终止类似于进程终止，也会产生（僵尸线程）
			
		线程等待：等待指定线程的退出，获取指定线程的退出返回值，回收退出线程的资源
		
		线程创建成功后，默认有一个joinable属性，处于joinable属性的线程退出时才必须要进行线程等待。
		
		线程分离：分离线程的属性，从joinable 设置为detach属性
					处于detach属性的线程退出后自动回收资源，不需要被等待
					分离线程前提：用户对线程的退出返回值不关心。
					
					pthread_detach
					
					线程分离可以是任意线程在任意时刻进行分离（线程一旦创建直接分离，线程入口函数中分离自己）
					
		线程安全：多个线程对同一个临界资源进行了不受保护的非原子操作
				  线程安全就是多个线程对临街资源进行操作，而不会造成数据二义性
	
			线程安全的实现：同步与互斥
				同步：临界资源访问的时序可控（保证合理）
				互斥：临界资源同一事件的唯一访问（保证安全）
				
				互斥的实现：使用互斥锁（只具有0/1的计数器）
					互斥锁使用步骤：
						1、定义互斥锁变量类型   pthread_mutex_t 
						2、初始化互斥锁         pthread_mutex_init
						3、加锁                 pthread_mutex_lock
						4、解锁					pthread_mutex_unlock
						5、销毁					pthread_mutex_destroy
						
						
					保护对临界资源的操作
					
				死锁：多个线程抢夺锁资源，但是因为抢夺顺序推进不当引起死锁，导致程序卡死
				
				产生死锁的四个必要条件：
					互斥条件（我加了锁，别人不能加）
					不可剥夺条件（我加的锁，别人不能解锁）
					请求与保持条件（拿到第一个锁后去请求第二个锁，但是第二个锁获取不到，第一个锁也不释放）
					环路等待条件
				
				预防：破坏必要条件
				
				避免：银行家算法、死锁检测算法
				
				同步的实现：使用条件变量
					pthread_cond_t     		定义
					pthread_cond_init  		初始化
					pthread_cond_wait  		等待    （包含了解锁、休眠、被唤醒后加锁三步原子操作）
					pthread_cond_signal     唤醒
					pthread_cond_destory 	销毁         
					
				条件变量搭配互斥锁一起使用的，因为条件变量的实现同步只是提供了等待与唤醒功能，并没有提供条件判断的功能，因此条件判断需要用户实现，但是条件的操作是一个临界资源的操作，因此需要保护，需要在条件判断之后加锁
				 
				如果加锁成功后，因为条件不满足而陷入休眠，就会导致卡死，因此需要在休眠之前解锁，并且解锁与休眠必须是原子操作。
				
				被唤醒之后，即将对临界资源进行操作，操作之前需要进行保护加锁
				

					
					 
					




























